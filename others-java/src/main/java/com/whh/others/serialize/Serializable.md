## Serializable 答疑

1、Intent传递对象时为什么要序列化？
   1.永久性保存对象，保存对象的字节序列到本地文件中；
   2.对象可以在网络中传递； 
   3.对象可以在IPC间传递。
   传输的对象 hashcode 一致，地址不同。
   
   为什么 Intent 使用 bundle 传输数据，而不是 map 结构？
   bundle对比map结构：bundle内部是个ArrayMap，其存储空间效率好。
   
2、为什么实现 Externalizable 的类必须有无参构造方法？
   序列化默认调用该类的无参构造方法。
   而反序列化不会调用该类的无参构造方法。

3、序列化和非序列化的关系，区别？
  序列化对象和反序列化对象是一次深拷贝操作；地址不同(枚举例外)

4、serialVersionUID 的作用？
    serialVersionUID 是为了保证成功进行反序列化，如果未指定，将自动生成，(只有同一次编译生成的class才会生成相同的serialVersionUID)
    1.serialVersionUID是序列化前后的唯一标识符，用于保持版本的兼容性，在版本升级时反序列化仍保持对象的唯一性
    2.默认如果没有显式定义过 serialVersionUID，那编译器会为它自动声明一个！
    
5、怎么做到不被序列化？
    1、凡是被static修饰的字段是不会被序列化的
    2、凡是被transient修饰符修饰的字段也是不会被序列化的

6、Serializable 和 Parcelable 的区别？
    Serializable java 接口
        通过 IO 对硬盘操作，速度慢；开销大，大量使用反射，序列化时产生大量的临时对象，从而引起频繁的GC，可以存储硬盘；
    Parcelelable Android 接口
        使用麻烦，直接在内存操作，效率高，自已实现封送和解封操作不需要用反射性能高，但不能使用在要将数据存储在硬盘。
        
7、序列化和持久化的区别与联系？
   序列化：将数据结构或对象转换为二进制的过程。
   持久化：把内存中的数据结构或对象永久的存储设备(如硬盘)，可以存储在磁盘文件中、XML、json、protbuf数据文件，
          持久化是将程序数据在持久状态和瞬时状态间转换的机制。JDBC就是一种持久化机制。文件IO也是一种持久化机制。

   
   

