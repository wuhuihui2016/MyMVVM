
[https://www.jianshu.com/p/59f880be1470]

1、绝大部分的对象都是朝生夕死。--区域：新生代。
2、对象熬过多次垃圾回收，越来越难回收。--区域：老年代。

一、System.gc()的理解
1、在默认情况下，通过System.gc() 或者Runtime.gc() ,getRuntime().gc() 的调用，会显式触发Full GC，
   同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。
2、而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用(无法保证马上触发GC)。
3、JVM 实现者可以通过 system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。
  在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。

二、Stop一the一World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。
   停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。
1、可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。
 分析工作必须在一个能确保一致性的快照中进行
 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上V- - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
2、被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样， 所以我们需要减少STW的发生。
3、STW事件和采用哪款GC无关，所有的GC都有这个事件。
4、哪怕是G1也不能完全避免Stop一the一world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。
5、STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。
6、开发中不要用System.gc()；会导致Stop一the一world的发生。

可达性分析算法解决两个相互引用导致无法回收的，引用计数法无法解决该问题。
对象的存活：finalize() 只能被执行一次，尽量不使用，不能确保能救活对象

三、强引用（StrongReference）、软引用（Soft Reference） 、弱引用（Weak Reference） 和虚引用（Phantom Reference） 
1、强引用（StrongReference） ：不回收
   最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object（ ）”这种引用关系。
   无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
2、软引用（SoftReference） ：不回收
   在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
   软引用通常用来实现内存敏感的缓存
3、弱引用（WeakReference） ：发现即回收  【实际用得多】
   被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
4、虚引用（PhantomReference） ：对象回收跟踪
   一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。
   为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知(回收跟踪)。
   
 Android 基本是堆内存溢出
   
四、JDK
   C语言在寄存器运行，寄存器运行快(基于硬件)，移植性差
   java 解释执行基于栈，效率偏低
   <=jdk1.7   方法区
   >=jdk1.8   元空间 (机器内存，不受限制，方便拓展，会挤压堆空间)
     [https://www.jianshu.com/p/a6f19189ec62]
   查看资料《JVM内存管理深度剖析, GC算法与底层原理.docx》、《JVM内存管理深度剖析, GC算法与底层原理.ppt》

